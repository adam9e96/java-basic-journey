# 실무에서 사용하는 업캐스팅 다운 캐스팅 사례

## 1. 인터페이스 기반 개발 (업캐스팅)

실무에선 보통 **부모 타입(인터페이스/추상 클래스)** 으로 코드를 짜고, 실제 동작은 자식 클래스(구현체)가 담당해.
예를 들어 **DAO 패턴**:

```java
// 부모 인터페이스
public interface UserRepository {
    User findById(Long id);
    void save(User user);
}

// 자식 구현체 (DB 연동)
public class MySQLUserRepository implements UserRepository {
    @Override
    public User findById(Long id) {
        System.out.println("MySQL에서 조회");
        return new User(id, "adam");
    }
    @Override
    public void save(User user) {
        System.out.println("MySQL에 저장: " + user.getName());
    }
}

// 자식 구현체 (메모리 저장)
public class MemoryUserRepository implements UserRepository {
    private Map<Long, User> store = new HashMap<>();
    @Override
    public User findById(Long id) {
        return store.get(id);
    }
    @Override
    public void save(User user) {
        store.put(user.getId(), user);
    }
}

// 서비스 코드 (업캐스팅 활용)
public class UserService {
    private final UserRepository repository;

    // 업캐스팅: 구체 클래스가 아닌 인터페이스(UserRepository) 기준으로 받음
    public UserService(UserRepository repository) {
        this.repository = repository;
    }

    public void registerUser(User user) {
        repository.save(user);
    }
}
```

👉 이렇게 하면 `UserService`는 DB가 MySQL인지, 메모리인지 몰라도 됨.
실무에서 **DI(의존성 주입)** 할 때도 다 업캐스팅 개념으로 동작하는 거야.

---

## 2. 이벤트 처리 (업캐스팅 + 다운캐스팅)

GUI나 Spring MVC 같은 곳에선, 보통 **부모 타입 이벤트**를 받고 필요할 때만 다운캐스팅한다.

```java
public class EventHandler {
    public void handle(Event e) {
        if (e instanceof MouseEvent) {
            MouseEvent me = (MouseEvent) e;  // 다운캐스팅
            System.out.println("마우스 클릭 좌표: " + me.getX() + ", " + me.getY());
        } else if (e instanceof KeyEvent) {
            KeyEvent ke = (KeyEvent) e;      // 다운캐스팅
            System.out.println("입력된 키: " + ke.getKeyChar());
        }
    }
}
```

👉 이벤트 루프는 `Event`라는 **부모 타입**을 기준으로 받고, 필요할 때만 자식 타입으로 **다운캐스팅** 해서 상세 처리.
이런 구조가 Swing, AWT, Spring DispatcherServlet 같은 곳에서 다 쓰인다.

---

## 3. 컬렉션과 다형성 (업캐스팅 활용)

Spring Boot에서 서비스 객체들을 한 번에 관리하는 경우:

```java
public interface Payment {
    void pay(int amount);
}

public class KakaoPay implements Payment {
    @Override
    public void pay(int amount) {
        System.out.println("카카오페이로 " + amount + "원 결제");
    }
}

public class CreditCard implements Payment {
    @Override
    public void pay(int amount) {
        System.out.println("신용카드로 " + amount + "원 결제");
    }
}

public class PaymentProcessor {
    private final List<Payment> payments;

    // 여러 결제수단을 업캐스팅해서 한 컬렉션에 담음
    public PaymentProcessor(List<Payment> payments) {
        this.payments = payments;
    }

    public void processAll(int amount) {
        for (Payment p : payments) {
            p.pay(amount);  // 다형성 적용
        }
    }
}
```

👉 `PaymentProcessor`는 **업캐스팅** 덕분에 결제수단이 늘어나도 코드 수정 없이 그대로 작동함.

---

## 4. 다운캐스팅 실무적 케이스 (특수 기능 접근)

보통은 업캐스팅으로 충분한데, **특정 구현체 기능이 필요할 때만** 다운캐스팅해.

예: JDBC에서 `Connection` 은 인터페이스지만, 특정 DB의 고급 기능을 쓰고 싶을 때.

```java
Connection conn = dataSource.getConnection();

// 표준 JDBC 메서드 (업캐스팅 상태)
conn.prepareStatement("SELECT * FROM users");

// 특정 구현체 기능 (다운캐스팅 필요)
if (conn.isWrapperFor(com.mysql.cj.jdbc.JdbcConnection.class)) {
    com.mysql.cj.jdbc.JdbcConnection mysqlConn = 
        conn.unwrap(com.mysql.cj.jdbc.JdbcConnection.class);
    mysqlConn.abortInternal(); // MySQL 전용 기능
}
```

👉 다운캐스팅은 이렇게 **표준 API에 없는 특수 기능**을 쓰고 싶을 때 제한적으로 활용해.

---

📌 정리:

* **업캐스팅** → 실무 대부분에서 쓰임 (인터페이스 기반 개발, 다형성, DI, 컬렉션 관리)
* **다운캐스팅** → 가끔 필요할 때만 (특정 구현체 기능, 이벤트 상세 처리 등)

정확히 이해했어 👍
네가 정리한 게 바로 핵심이야.

---

## ✅ 업캐스팅

* **실행부(메인, 서비스, 컨트롤러 등)** 에서는 부모 타입만 의존.
* **구현체 선택**은 주입(DI) 단계에서만 바꿔주면 됨.
* 따라서 실행부 코드는 손대지 않고도 기능 교체 가능 → **유연성, 확장성** 확보.

👉 실무에서 Spring 같은 프레임워크가 이걸 전제로 돌아감.

```java
Payment payment = new KakaoPay();   // 업캐스팅
payment.pay(1000);
```

나중에 `CreditCard`로 갈아타도 `payment.pay(1000)` 로직은 그대로 유지.

---

## ✅ 다운캐스팅

* 부모 타입으로 실행하던 중, **자식 클래스 전용 기능**이 필요할 때 강제로 캐스팅.
* 하지만 이건 설계적으로는 권장되지 않고, “정말 자식만의 기능”이 필요할 때만 사용.

```java
Payment payment = new KakaoPay();   // 업캐스팅

if (payment instanceof KakaoPay) {
    KakaoPay kakao = (KakaoPay) payment; // 다운캐스팅
    kakao.refund(500);   // KakaoPay만의 기능
}
```

* 업캐스팅은 **메인 로직 변경 없이 구현체 교체 가능**
* 다운캐스팅은 **부모 타입으로 쓰던 객체에서 자식 고유 기능을 쓸 때**